Part 1 - Introduction and Setting up the REPL
==============================================

As a developer, I use relational databases every day, but they're a black box to me. Some questions I have:

* What format is data saved in? (in memory and on disk)
* When does it move from memory to disk?
* Why can there only be one primary key per table?
* How does rolling back a transaction work?
* How are indexes formatted?
* When and how does a full table scan happen?
* What format is a prepared statement saved in?

In other words, how does a database **work**?

To figure things out, we're writing a database from scratch in Zig. It's modeled off SQLite because it is designed to be small with fewer features than MySQL or PostgreSQL, so we have a better hope of understanding it. The entire database is stored in a single file!

SQLite Architecture
-------------------

A query goes through a chain of components in order to retrieve or modify data. The **front-end** consists of the:

* tokenizer
* parser
* code generator

The input to the front-end is a SQL query. The output is SQLite virtual machine bytecode (essentially a compiled program that can operate on the database).

The **back-end** consists of the:

* virtual machine
* B-tree
* pager
* os interface

The **virtual machine** takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree.

Each **B-tree** consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager.

The **pager** receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory.

The **os interface** is the layer that differs depending on which operating system was compiled for. In Zig, we use the cross-platform standard library.

Making a Simple REPL
--------------------

SQLite starts a read-execute-print loop when you start it from the command line:

.. code-block:: shell

    ~ sqlite3
    SQLite version 3.16.0 2016-11-04 19:09:39
    Enter ".help" for usage hints.
    Connected to a transient in-memory database.
    sqlite> .exit
    ~

To do that, our main function will have an infinite loop that prints the prompt, gets a line of input, then processes that line of input.

InputBuffer Module
------------------

We define ``InputBuffer`` as a struct wrapping the state we need to store to interact with stdin. In Zig, we pass an explicit allocator for memory management:

.. literalinclude:: ../../src/phase01/input.zig
   :language: zig
   :caption: src/phase01/input.zig
   :linenos:

Key Zig Concepts
~~~~~~~~~~~~~~~~

**Explicit Allocators**: Unlike C's ``malloc``, Zig requires passing allocators explicitly. This makes memory management visible and testable.

**Error Unions**: Functions that can fail return ``!T`` (error union). The ``try`` keyword propagates errors up.

**Defer**: The ``defer`` statement ensures cleanup code runs when leaving scope, preventing resource leaks.

Main Entry Point
----------------

The main function demonstrates the REPL:

.. literalinclude:: ../../src/phase01/main.zig
   :language: zig
   :caption: src/phase01/main.zig
   :linenos:

Unit Tests
----------

Zig has built-in test support. Tests for InputBuffer:

.. literalinclude:: ../../src/phase01/tests.zig
   :language: zig
   :caption: src/phase01/tests.zig
   :linenos:

Let's Try It
------------

.. code-block:: shell

    $ zig build run-phase01
    Phase 01: Basic REPL
    Type '.exit' to quit, anything else shows unrecognized message.

    db > .tables
    Unrecognized command '.tables'.
    db > .exit

Running Tests
~~~~~~~~~~~~~

.. code-block:: shell

    $ zig build test-phase01
    All 4 tests passed.

Exports for Next Phase
----------------------

This phase exports for use by Phase 02:

* ``InputBuffer`` - Struct for managing input
* ``printPrompt()`` - Print the prompt
* ``readInput()`` - Read a line from stdin

Alright, we've got a working REPL. In the next part, we'll start developing our command language.

Next: :doc:`part02` - World's Simplest SQL Compiler and Virtual Machine
